{
  "docs": [
    {
      "_id": "rphistory",
      "language": "javascript",
      "lists": {
        "constituents": "function(head, req) {\n    var view = req.path.slice(2 + req.path.indexOf(\"_list\"))[0];\n    if (view === \"eventsByAccount\") {\n\n        var stream = false;\n        if (req.query.stream || req.query.include_stats)\n            stream = true;\n\n        var constituents = {\n            \"users\": [],\n            \"gateways\": [],\n            // \"hot_wallets\": [],\n            \"market_makers\": [],\n            \"merchants\": []\n        };\n        var row;\n        while (row = getRow()) {\n            var acct = row.key[0];\n\n            if (row.value.TrustSet > 100) {\n                // gateway\n                if (!stream) {\n                    constituents.gateways.push(acct);\n                } else {\n                    send({type: \"gateway\", acct: acct, stats: row.value});\n                }\n            // } else if (row.value.Payment > 200 && row.value.TrustSet < 100){\n            //     // hot wallet\n            //     if (!stream) {\n            //         constituents.hot_wallets.push(acct);\n            //     } else {\n            //         send({type: \"hot_wallet\", acct: acct, stats: row.value});\n            //     }\n            } else if (row.value.OfferCreate + row.value.OfferCancel > 100) {\n                // market maker\n                if (!stream) {\n                    constituents.market_makers.push(acct);\n                } else {\n                    send({type: \"market_maker\", acct: acct, stats: row.value});\n                }\n            } else if (row.value.Incoming_Payment > 200) {\n                // merchant\n                if (!stream) {\n                    constituents.merchants.push(acct);\n                } else {\n                    send({type: \"merchant\", acct: acct, stats: row.value});\n                }\n            } else {\n                // other\n                if (!stream) {\n                    constituents.users.push(acct);\n                } else {\n                    send({type: \"user\", acct: acct, stats: row.value});\n                }\n            }\n        }\n        if (!stream)\n            send(JSON.stringify(constituents));\n    } else {\n        send('Error, this view can only be used with the view \"eventsByAccount\"');\n    }\n}",
        "csv": "function(head, req) {\n    var row;\n    while (row = getRow()) {\n        var row_array = [];\n\n        if (typeof row.key === \"object\") {\n            var key = JSON.parse(row.key);\n            Object.keys(key).forEach(function(k) {\n                row_array.push(JSON.stringify(key[k]));\n            });\n        } else if (typeof row.key !== \"null\" || typeof row.key !== \"undefined\") {\n            row_array.push(row.key);\n        }\n\n        if (typeof row.value === \"object\") {\n            var value = JSON.parse(row.value);\n            Object.keys(value).forEach(function(k) {\n                row_array.push(JSON.stringify(value[k]));\n            });\n        } else if (typeof row.value !== \"null\" || typeof row.value !== \"undefined\") {\n            row_array.push(row.value);\n        }\n\n        var csv_row = row_array.join(',') + \"\\n\";\n        send(csv_row);\n    }\n}",
        "gateways": "function(head, req) {\n    var view = req.path.slice(2 + req.path.indexOf(\"_list\"))[0];\n    if (view === \"trustlineStatsByAccount\" || view === \"trustlineStatsByCurrency\") {\n\n        var row;\n        while (row = getRow()) {\n            if (row.value.incoming > 50 \n                && row.value.balance_change < 0) {\n                send(JSON.stringify(row) + \"\\n\");\n            }\n        }\n\n    } else {\n        send('Error, this view can only be used with the views \"trustlineStatsByCurrency\" and \"trustlineStatsByAccount\"');\n    }\n}",
        "hotwalletpotentials": "function(head, req) {\n    var view = req.path.slice(2 + req.path.indexOf(\"_list\"))[0];\n\n    if (view === \"trustlinesByAccount\") {\n        if (req.query.group_level === 2) {\n            var row;\n            var potentials;\n            while (row = getRow()) {\n                if (row.value.outgoing < 5\n                    && row.value.balance > 0) {\n\n                    var acct = row.key[0],\n                        curr = row.key[1];\n\n                    if (typeof potentials[acct] === \"undefined\")\n                        potentials[acct] = {};\n                    if (typeof potentials[acct][curr] === \"undefined\")\n                        potentials[acct][curr] = {};\n\n                    potentials[acct][curr].in = row.value.incoming;\n                    potentials[acct][curr].out = row.value.outgoing;\n                    potentials[acct][curr].bal = row.value.balance_change;\n                    potentials[acct][curr].trusted_parties = row.value.trusted_parties;\n                }\n            }\n            send(JSON.stringify(potentials));\n        } else {\n            send('Error, this view should be used with query group_level=2');\n        }\n    } else {\n        send('Error, this view can only be used with the view \"trustlinesByAccount\"');\n    }\n}",
        "sort": "function(head, req) {\n    var rows = [],\n        row;\n    while (row = getRow()) {\n        rows.push(row);\n    }\n    rows.sort(function(a, b) {\n        if (b.value > a.value) {\n            return 1;\n        } else {\n            return -1;\n        }\n    });\n    send(JSON.stringify({\"rows\": rows}));\n}",
        "streamRows": "function(head, req) {\n    var row;\n    while(row = getRow()){\n        send(JSON.stringify([row.key, row.value]) + \"\\n\");\n    }\n}",
        "trades": "function(head, req) {\n    var view = req.path.slice(2 + req.path.indexOf(\"_list\"))[0];\n    if (view === \"offersExercised\") {\n        if (req.query.group === \"true\") {\n\n            var row;\n            while (row = getRow()) {\n                var date_arr = row.key.slice(2),\n                    price = row.value.volume_weighted_avg,\n                    volume = row.value.vwav_denominator;\n\n                var timestamp = pad(date_arr[0],4) + \"-\" + pad(date_arr[1],2) + \"-\" + pad(date_arr[2],2) \n                                + \"T\" + pad(date_arr[3],2) + \":\" + pad(date_arr[4],2) + \":\" + pad(date_arr[5],2) + \"+0000\";\n\n                send(JSON.stringify([timestamp, price, volume]) + \"\\n\");\n            }\n        } else {\n            send('Error, this view should be used with query group=true');\n        }\n    } else {\n        send('Error, this view can only be used with the view \"offersExercised\"');\n    }\n\n    function pad (number, digits) {\n        var num_str = String(number);\n        while (num_str.length < digits) {\n            num_str = \"0\" + num_str;\n        }\n        return num_str;\n    }\n}",
        "xrp": "function(head, req) {\n    var view = req.path.slice(2 + req.path.indexOf(\"_list\"))[0];\n    if (view === \"xrp_totals\") {\n        if (req.query.group_level === \"1\") {\n\n            var total_only = false;\n            if (req.query.total_only)\n                total_only = true;\n\n            var xrp_total = 0;\n            var row;\n            while (row = getRow()) {\n                xrp_total += row.value[0];\n                if (!total_only)\n                    send(JSON.stringify([row.key[0], row.value[0]]));\n            }\n            if (total_only)\n                send(\"XRP Total: \" + (xrp_total / 1000000.0));\n\n        } else {\n            send('Error, this view should be used with query group_level=1');\n        }\n    } else {\n        send('Error, this view can only be used with the view \"xrp_totals\"');\n    }\n}"
      },
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n    if (userCtx && userCtx.roles && (userCtx.roles.indexOf('_admin') !== -1 ||\n        userCtx.roles.indexOf('write') !== -1)) {\n        return;\n    } else {\n        throw ({\n            forbidden: 'You do not have write access to this database'\n        });\n    }\n}",
      "views": {
        "account_tx": {
          "map": "function (doc) {\n\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        var tx = doc.transactions[t];\n\n        if (doc.transactions[t].metaData.TransactionResult !== \"tesSUCCESS\") \n            continue;\n\n        emit([tx.Account].concat(timestamp), tx);\n\n    }\n}",
          "reduce": "_count"
        },
        "accountsCreated": {
          "map": "function(doc) {\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        var tx = doc.transactions[t];\n\n        if (tx.metaData.TransactionResult !== \"tesSUCCESS\") \n                continue;\n\n        for (var n = 0, nodes = tx.metaData.AffectedNodes.length; n < nodes; n++) {\n\n            if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"CreatedNode\") \n                && tx.metaData.AffectedNodes[n].CreatedNode.LedgerEntryType === \"AccountRoot\") {\n                var cnode = tx.metaData.AffectedNodes[n].CreatedNode;\n\n                emit(timestamp, cnode.NewFields.Account);\n            }\n        }\n    }\n}",
          "reduce": "_count"
        },
        "count": {
          "map": "function(doc) {\n  var date = new Date(doc.close_time_timestamp),\n      key = [null, date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours()],\n      transactions = doc.transactions;\n\n  for (var i = 0, n = transactions.length; i < n; ++i) {\n    var t = transactions[i],\n        type = t.TransactionType;\n    if (!type) continue;\n    var currency = type === \"Payment\" ? symbol(t.Amount)\n          : type === \"TrustSet\" ? symbol(t.LimitAmount)\n          : type === \"OfferCreate\" ? symbol(t.TakerPays) + \"/\" + symbol(t.TakerGets)\n          : null;\n    if (currency == null) continue;\n    var k = key.slice();\n    k[0] = type;\n    emit(k, currency);\n  }\n}\n\nfunction symbol(d) {\n  return d.currency || \"XRP\";\n}",
          "reduce": "function(keys, values, rereduce) {\n  var counts = {};\n  if (rereduce) for (var i = 0, n = values.length; i < n; ++i) {\n    var value = values[i];\n    for (var key in value) {\n      if (counts.hasOwnProperty(key)) counts[key] += value[key];\n      else counts[key] = value[key];\n    }\n  } else for (var i = 0, n = values.length; i < n; ++i) {\n    var key = values[i];\n    if (counts.hasOwnProperty(key)) ++counts[key];\n    else counts[key] = 1;\n  }\n  return counts;\n}"
        },
        "eventsByAccount": {
          "map": "function (doc) {\n\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        var tx = doc.transactions[t];\n\n        if (doc.transactions[t].metaData.TransactionResult !== \"tesSUCCESS\") \n            continue;\n\n        emit([tx.Account].concat(timestamp), tx);\n        if (typeof tx.Destination === \"string\") {\n            emit([tx.Destination].concat(timestamp), tx);\n        }\n        // var tx_str = JSON.stringify(tx);\n        // var matches = tx_str.match(/\\\"[rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz]{27,53}\\\"/g);\n        // var all_parties = [];\n        // matches.forEach(function(rip_addr){\n        //     if (all_parties.indexOf(rip_addr))\n        //         all_parties.push(rip_addr);\n        // });\n\n        // all_parties.forEach(function(rip_addr){\n        //     emit([rip_addr].concat(timestamp), tx);\n        // });\n    }\n}",
          "reduce": "function (keys, values, rereduce) {\n\n    if (!rereduce) {\n\n        var types = {\n            Payment: 0,\n            OfferCreate: 0,\n            OfferCancel: 0,\n            TrustSet: 0,\n            Incoming_Payment: 0\n        };\n        var total = 0;\n\n        for (var v = 0, vlen = values.length; v < vlen; v++) {\n            var tx = values[v];\n\n            if (tx.Account === keys[v][0]) {\n                // tx initiated by this account\n\n                if (types.hasOwnProperty(tx.TransactionType)) {\n                    types[tx.TransactionType] += 1;\n                    total += 1;\n                }\n            } \n            else if (tx.TransactionType === \"Payment\" && tx.Destination === keys[v][0]) {\n                types[Incoming_Payment] += 1;\n            }\n        }\n\n        types.Total_Initiated = total;\n        return types;\n\n    } else {\n\n        var results = values[0];\n        var tx_types = Object.keys(results);\n\n        for (var v = 1, vlen = values.length; v < vlen; v++) {\n            for (var t = 0; t < tx_types.length; t++) {\n                var tx_type = tx_types[t];\n                results[tx_type] += values[v][tx_type];\n            }\n        }\n\n        return results;\n    }\n}"
        },
        "feesPaid": {
          "map": "function (doc) {\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        if (doc.transactions[t].metaData.TransactionResult !== \"tesSUCCESS\") \n            continue;\n        emit(timestamp, parseInt(doc.transactions[t].Fee, 10));\n    }\n}",
          "reduce": "_sum"
        },
        "indexesAndTimesByIndex": {
          "map": "function (doc) {\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    var ledger_index = doc.ledger_index;\n\n    emit(ledger_index, timestamp);\n\n}"
        },
        "indexesAndTimesByTime": {
          "map": "function (doc) {\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    var ledger_index = doc.ledger_index;\n\n    emit(timestamp, ledger_index);\n\n}"
        },
        "offersExercised": {
          "map": "function(doc) {\n\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n\n        if (doc.transactions[t].TransactionType === \"Payment\" || doc.transactions[t].TransactionType === \"OfferCreate\") {\n\n            var tx = doc.transactions[t],\n                meta = tx.metaData,\n                affNodes = meta.AffectedNodes;\n\n            if (meta.TransactionResult !== \"tesSUCCESS\")\n                continue;\n\n            for (var n = 0, num_nodes = affNodes.length; n < num_nodes; n++) {\n                var node;\n\n                if (affNodes[n].hasOwnProperty(\"ModifiedNode\") && affNodes[n].ModifiedNode.LedgerEntryType === \"Offer\") {\n                    node = affNodes[n].ModifiedNode;\n                } else if (affNodes[n].hasOwnProperty(\"DeletedNode\") && affNodes[n].DeletedNode.LedgerEntryType === \"Offer\") {\n                    node = affNodes[n].DeletedNode;\n                } else {\n                    continue;\n                }\n\n                // TakerPays and TakerGets were modified, meaning the offer was taken\n                if (node.PreviousFields.hasOwnProperty(\"TakerPays\") \n                    && node.PreviousFields.hasOwnProperty(\"TakerGets\")) {\n\n                    var pay_curr, pay_amnt;\n                    var exchange_rate = node.exchange_rate;\n\n                    if (typeof node.PreviousFields.TakerPays === \"object\") {\n                        pay_curr = [node.PreviousFields.TakerPays.currency, node.PreviousFields.TakerPays.issuer];\n                        pay_amnt = node.PreviousFields.TakerPays.value - node.FinalFields.TakerPays.value;\n                    } else {\n                        pay_curr = [\"XRP\"];\n                        pay_amnt = (node.PreviousFields.TakerPays - node.FinalFields.TakerPays) / 1000000.0; // convert from drops\n                        exchange_rate = exchange_rate / 1000000.0;\n                    }\n\n                    var get_curr, get_amnt;\n                    if (typeof node.PreviousFields.TakerGets === \"object\") {\n                        get_curr = [node.PreviousFields.TakerGets.currency, node.PreviousFields.TakerGets.issuer];\n                        get_amnt = node.PreviousFields.TakerGets.value - node.FinalFields.TakerGets.value;\n                    } else {\n                        get_curr = [\"XRP\"];\n                        get_amnt = (node.PreviousFields.TakerGets - node.FinalFields.TakerGets) / 1000000.0;\n                        exchange_rate = exchange_rate * 1000000.0;\n                    }\n\n                    emit([pay_curr, get_curr].concat(timestamp), [pay_amnt, get_amnt, exchange_rate]);\n                    emit([get_curr, pay_curr].concat(timestamp), [get_amnt, pay_amnt, 1 / exchange_rate]);\n\n                }\n            }\n        }\n    }\n}",
          "reduce": "function(keys, values, rereduce) {\n\n    if (!rereduce) {\n\n\n        var first_price = (typeof values[0][2] === \"number\" ? values[0][2] : (values[0][0] / values[0][1])),\n            first_time = keys[0][0].slice(2);\n\n        // initial values\n        var stats = {\n            open_time: first_time,\n            close_time: first_time,\n\n            open: first_price,\n            close: first_price,\n            high: first_price,\n            low: first_price,\n\n            curr1_vwav_numerator: 0,\n            curr1_volume: 0,\n            curr2_volume: 0,\n            num_trades: 0\n        };\n\n        // compute stats for this set of values outputted by the map fn\n        for (var v = 0, vlen = values.length; v < vlen; v++) {\n            var trade = values[v],\n                trade_time = keys[v][0].slice(2),\n                trade_rate = (typeof trade[2] === \"number\" ? trade[2] : (trade[0] / trade[1]));\n\n            if (lessThan(trade_time, stats.open_time)) {\n                stats.open_time = trade_time;\n                stats.open = trade_rate;\n            }\n            if (lessThan(stats.close_time, trade_time)) {\n                stats.close_time = trade_time;\n                stats.close = trade_rate;\n            }\n\n            stats.high = Math.max(stats.high, trade_rate);\n            stats.low = Math.min(stats.low, trade_rate);\n            stats.curr1_vwav_numerator += trade_rate * trade[0];\n            stats.curr1_volume += trade[0];\n            stats.curr2_volume += trade[1];\n            stats.num_trades++;\n        }\n\n        stats.volume_weighted_avg = stats.curr1_vwav_numerator / stats.curr1_volume;\n\n        return stats;\n\n    } else {\n\n        var stats = values[0];\n\n        // update the stats for each of the segments of results\n        for (var v = 1, vlen = values.length; v < vlen; v++) {\n            var segment = values[v];\n\n            if (lessThan(segment.open_time, stats.open_time)) {\n                stats.open_time = segment.open_time;\n                stats.open = segment.open;\n            }\n            if (lessThan(stats.close_time, segment.close_time)) {\n                stats.close_time = segment.close_time;\n                stats.close = segment.close;\n            }\n\n            stats.high = Math.max(stats.high, segment.high);\n            stats.low = Math.min(stats.low, segment.low);\n\n            stats.curr1_vwav_numerator += segment.curr1_vwav_numerator;\n            stats.curr1_volume += segment.curr1_volume;\n            stats.curr2_volume += segment.curr2_volume;\n            stats.num_trades += segment.num_trades;\n        }\n\n        stats.volume_weighted_avg = stats.curr1_vwav_numerator / stats.curr1_volume;\n\n        return stats;\n\n    }\n\n    function lessThan(arr1, arr2) {\n        if (arr1.length !== arr2.length)\n            return false;\n\n        for (var i = 0; i < arr1.length; i++) {\n            if (arr1[i] < arr2[i]) {\n                return true;\n            } else if (arr1[i] > arr2[i]) {\n                return false;\n            } else {\n                continue;\n            }\n        }\n\n        return false;\n    }\n}"
        },
        "offersUnfunded": {
          "map": "function(doc) {\n\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n\n        if (doc.transactions[t].TransactionType === \"Payment\" || doc.transactions[t].TransactionType === \"OfferCreate\") {\n\n            var tx = doc.transactions[t],\n                meta = tx.metaData,\n                affNodes = meta.AffectedNodes;\n\n            if (meta.TransactionResult !== \"tesSUCCESS\")\n                continue;\n\n            for (var n = 0, num_nodes = affNodes.length; n < num_nodes; n++) {\n                var node;\n\n                if (affNodes[n].hasOwnProperty(\"DeletedNode\") && affNodes[n].DeletedNode.LedgerEntryType === \"Offer\") {\n                    node = affNodes[n].DeletedNode;\n                } else {\n                    continue;\n                }\n\n                // TakerPays and TakerGets were modified, meaning the offer was taken\n                if (node.PreviousFields.hasOwnProperty(\"TakerPays\") \n                    && node.PreviousFields.hasOwnProperty(\"TakerGets\")) {\n\n                    var pay_curr, pay_amnt_unfunded;\n                    var exchange_rate = node.exchange_rate;\n\n                    if (typeof node.PreviousFields.TakerPays === \"object\") {\n                        pay_curr = [node.PreviousFields.TakerPays.currency, node.PreviousFields.TakerPays.issuer];\n                        pay_amnt_unfunded = parseFloat(node.FinalFields.TakerPays.value);\n                    } else {\n                        pay_curr = [\"XRP\"];\n                        pay_amnt_unfunded = parseFloat(node.FinalFields.TakerPays) / 1000000.0; // convert from drops\n                        exchange_rate = exchange_rate / 1000000.0;\n                    }\n\n                    var get_curr, get_amnt_unfunded;\n                    if (typeof node.PreviousFields.TakerGets === \"object\") {\n                        get_curr = [node.PreviousFields.TakerGets.currency, node.PreviousFields.TakerGets.issuer];\n                        get_amnt_unfunded = parseFloat(node.FinalFields.TakerGets.value);\n                    } else {\n                        get_curr = [\"XRP\"];\n                        get_amnt_unfunded = parseFloat(node.FinalFields.TakerGets) / 1000000.0;\n                        exchange_rate = exchange_rate * 1000000.0;\n                    }\n\n                    emit([pay_curr, get_curr].concat(timestamp), [pay_amnt_unfunded, get_amnt_unfunded, exchange_rate]);\n                    emit([get_curr, pay_curr].concat(timestamp), [get_amnt_unfunded, pay_amnt_unfunded, 1 / exchange_rate]);\n\n                }\n            }\n        }\n    }\n}",
          "reduce": "function(keys, values, rereduce) {\n\n    if (!rereduce) {\n\n\n        var first_price = (typeof values[0][2] === \"number\" ? values[0][2] : (values[0][0] / values[0][1]));\n\n        // initial values\n        var stats = {\n            curr1_volume_unfunded: 0,\n            curr2_volume_unfunded: 0,\n            num_trades: 0\n        };\n\n        // compute stats for this set of values outputted by the map fn\n        for (var v = 0, vlen = values.length; v < vlen; v++) {\n            var trade = values[v];\n\n            stats.curr1_volume_unfunded += trade[0];\n            stats.curr2_volume_unfunded += trade[1];\n            stats.num_trades++;\n        }\n\n        return stats;\n\n    } else {\n\n        var stats = values[0];\n\n        // update the stats for each of the segments of results\n        for (var v = 1, vlen = values.length; v < vlen; v++) {\n            var segment = values[v];\n\n            stats.curr1_volume_unfunded += segment.curr1_volume_unfunded;\n            stats.curr2_volume_unfunded += segment.curr2_volume_unfunded;\n            stats.num_trades += segment.num_trades;\n        }\n\n        return stats;\n\n    }\n}"
        },
        "sum": {
          "map": "function(doc) {\n  var date = new Date(doc.close_time_timestamp),\n      key = [null, date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours()],\n      transactions = doc.transactions;\n\n  for (var i = 0, n = transactions.length; i < n; ++i) {\n    var t = transactions[i],\n        type = t.TransactionType;\n    if (!type) continue;\n    var pair = type === \"Payment\" ? value(t.Amount)\n          : type === \"TrustSet\" ? value(t.LimitAmount)\n          //: type === \"OfferCreate\" ? value(t.TakerPays) + \"/\" + value(t.TakerGets)\n          : null;\n    if (pair == null) continue;\n    var k = key.slice();\n    k[0] = type;\n    emit(k, pair);\n  }\n}\n\nfunction value(d) {\n  return d.currency ? [+d.value, d.currency] : [+d, \"XRP\"];\n}",
          "reduce": "function(keys, values, rereduce) {\n  var counts = {};\n  if (rereduce) for (var i = 0, n = values.length; i < n; ++i) {\n    var value = values[i];\n    for (var key in value) {\n      if (counts.hasOwnProperty(key)) counts[key] += value[key];\n      else counts[key] = value[key];\n    }\n  } else for (var i = 0, n = values.length; i < n; ++i) {\n    var pair = values[i],\n        value = pair[0],\n        key = pair[1];\n    if (counts.hasOwnProperty(key)) counts[key] += value;\n    else counts[key] = value;\n  }\n  return counts;\n}"
        },
        "transactionsByAccount": {
          "map": "function(doc) {\n    // doc will be a JSON object of the same form as: http://ct.ripple.com:5984/_utils/document.html?rphist/0003100000\n\n    var key = [];\n    var value = {};\n\n    // emit is CouchDB's function that is effectively \"return\" for map functions\n    emit(key, value);\n}",
          "reduce": "function(keys, values, rereduce) {\n\n    if (!rereduce) {\n        // in this case, this function is being applied to\n        // the results of your map function\n        // such that keys[0] and values[0] will be what your map function emitted\n        // for the first ledger in this set\n\n        var stats = {};\n\n        // reduce functions use return instead of emit\n        return stats;\n    } else {\n        // in this case, this function is being applied to a small batch\n        // of results from this very same function\n        // this is a little tricky but keys will be null and values\n        // will be an array of objects of the form you returned in the !rereduce case\n\n        // I found this blog post to be helpful: http://www.bitsbythepound.com/writing-a-reduce-function-in-couchdb-370.html\n\n        var stats = values[0];\n\n        // compress the other values into a single object\n\n        return stats;\n    }\n\n}"
        },
        "trustlineBalancesByAccount": {
          "map": "function(doc) {\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        var tx = doc.transactions[t];\n\n        if (tx.metaData.TransactionResult !== \"tesSUCCESS\") \n                continue;\n\n        for (var n = 0, nodes = tx.metaData.AffectedNodes.length; n < nodes; n++) {\n\n            if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"CreatedNode\") && tx.metaData.AffectedNodes[n].CreatedNode.LedgerEntryType === \"RippleState\") {\n                var cnode = tx.metaData.AffectedNodes[n].CreatedNode;\n\n                var currency = cnode.NewFields.Balance.currency,\n                    high_party = cnode.NewFields.HighLimit.issuer,\n                    low_party = cnode.NewFields.LowLimit.issuer;\n\n                if (parseFloat(cnode.NewFields.Balance.value) !== 0) {\n                    emit([high_party, currency, low_party].concat(timestamp), [(0 - parseFloat(cnode.NewFields.Balance.value)), (0 - parseFloat(cnode.NewFields.Balance.value))]);\n                    emit([low_party, currency, high_party].concat(timestamp), [parseFloat(cnode.NewFields.Balance.value), parseFloat(cnode.NewFields.Balance.value)]);\n                }\n\n            } else if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"ModifiedNode\") && tx.metaData.AffectedNodes[n].ModifiedNode.LedgerEntryType === \"RippleState\") {\n                var mnode = tx.metaData.AffectedNodes[n].ModifiedNode;\n\n                // balance changed\n                if (mnode.PreviousFields.hasOwnProperty(\"Balance\")) {\n\n                    var currency = mnode.FinalFields.Balance.currency,\n                        low_party = mnode.FinalFields.LowLimit.issuer,\n                        high_party = mnode.FinalFields.HighLimit.issuer;\n\n                    var final_bal = parseFloat(mnode.FinalFields.Balance.value),\n                        prev_bal = parseFloat(mnode.PreviousFields.Balance.value);\n\n                    emit([low_party, currency, high_party].concat(timestamp), [(final_bal - prev_bal), final_bal]);\n                    emit([high_party, currency, low_party].concat(timestamp), [(0 - (final_bal - prev_bal)), (0 - final_bal)]);\n\n                }\n            }\n        }\n    }\n}",
          "reduce": "function(keys, values, rereduce) {\n\n    if (!rereduce) {\n\n        var results = {\n            change: 0,\n            latest_time: keys[0][0].slice(3),\n            latest: values[0][1]\n        };\n\n        for (var v = 0, vlen = values.length; v < vlen; v++) {\n            var time = keys[v][0].slice(3);\n            if (lessThan(results.latest_time, time)) {\n                results.latest_time = time;\n                results.latest = values[v][1];\n            }\n\n            results.change += values[v][0];\n        }\n        return results;\n\n    } else {\n\n        var results = values[0];\n\n        for (var v = 1, vlen = values.length; v < vlen; v++) {\n            var segment = values[v];\n            if (lessThan(results.latest_time, segment.latest_time)) {\n                results.latest_time = segment.latest_time;\n                results.latest = segment.latest;\n            }\n            results += segment.change;\n        }\n\n        return results;\n    }\n\n    function lessThan(arr1, arr2) {\n        if (arr1.length !== arr2.length)\n            return false;\n\n        for (var i = 0; i < arr1.length; i++) {\n            if (arr1[i] < arr2[i]) {\n                return true;\n            } else if (arr1[i] > arr2[i]) {\n                return false;\n            } else {\n                continue;\n            }\n        }\n\n        return false;\n    }\n}"
        },
        "trustlineStatsByAccount": {
          "map": "function(doc) {\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        var tx = doc.transactions[t];\n\n        if (tx.metaData.TransactionResult !== \"tesSUCCESS\") \n                continue;\n\n        for (var n = 0, nodes = tx.metaData.AffectedNodes.length; n < nodes; n++) {\n\n            if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"CreatedNode\") && tx.metaData.AffectedNodes[n].CreatedNode.LedgerEntryType === \"RippleState\") {\n                var cnode = tx.metaData.AffectedNodes[n].CreatedNode;\n\n                var currency = cnode.NewFields.Balance.currency,\n                    high_party = cnode.NewFields.HighLimit.issuer,\n                    low_party = cnode.NewFields.LowLimit.issuer;\n\n                if (parseFloat(cnode.NewFields.LowLimit.value) > 0) {\n                    emit([high_party, currency].concat(timestamp), {incoming: 1});\n                    emit([low_party, currency].concat(timestamp), {outgoing: 1}); //, trusted_parties: [high_party]});\n                }\n\n                if (parseFloat(cnode.NewFields.HighLimit.value) > 0) {\n                    emit([low_party, currency].concat(timestamp), {incoming: 1});\n                    emit([high_party, currency].concat(timestamp), {outgoing: 1}); //, trusted_parties: [low_party]});\n                }\n\n                if (parseFloat(cnode.NewFields.Balance.value) !== 0) {\n                    emit([high_party, currency].concat(timestamp), {balance_change: 0 - parseFloat(cnode.NewFields.Balance.value)});\n                    emit([low_party, currency].concat(timestamp), {balance_change: parseFloat(cnode.NewFields.Balance.value)});\n                }\n\n            } else if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"ModifiedNode\") && tx.metaData.AffectedNodes[n].ModifiedNode.LedgerEntryType === \"RippleState\") {\n                var mnode = tx.metaData.AffectedNodes[n].ModifiedNode;\n\n                // high limit changed\n                if (mnode.PreviousFields.hasOwnProperty(\"HighLimit\")) {\n\n                    // adding trust line\n                    if (parseFloat(mnode.PreviousFields.HighLimit.value) === 0 && parseFloat(mnode.FinalFields.HighLimit.value) > 0) {\n\n                        var currency = mnode.FinalFields.LowLimit.currency,\n                            trusting_party = mnode.FinalFields.HighLimit.issuer,\n                            trusted_party = mnode.FinalFields.LowLimit.issuer;\n\n                        emit([trusted_party, currency].concat(timestamp), {incoming: 1});\n                        emit([trusting_party, currency].concat(timestamp), {outgoing: 1}); //, trusted_parties: [trusted_party]});\n                    }\n\n                    // removing trust line\n                    if (parseFloat(mnode.PreviousFields.HighLimit.value) > 0 && parseFloat(mnode.FinalFields.HighLimit.value) === 0) {\n\n                        var currency = mnode.FinalFields.LowLimit.currency,\n                            trusting_party = mnode.FinalFields.HighLimit.issuer,\n                            trusted_party = mnode.FinalFields.LowLimit.issuer;\n\n                        emit([trusted_party, currency].concat(timestamp), {incoming: -1});\n                        emit([trusting_party, currency].concat(timestamp), {outgoing: -1});\n                    }\n\n                }\n\n\n                // low limit changed\n                if (mnode.PreviousFields.hasOwnProperty(\"LowLimit\")) {\n\n                    // adding trust line\n                    if (parseFloat(mnode.PreviousFields.LowLimit.value) === 0 && parseFloat(mnode.FinalFields.LowLimit.value) > 0) {\n\n                        var currency = mnode.FinalFields.HighLimit.currency,\n                            trusting_party = mnode.FinalFields.LowLimit.issuer,\n                            trusted_party = mnode.FinalFields.HighLimit.issuer;\n\n                        emit([trusted_party, currency].concat(timestamp), {incoming: 1});\n                        emit([trusting_party, currency].concat(timestamp), {outgoing: 1}); //, trusted_parties: [trusted_party]});\n                    }\n\n                    // removing trust line\n                    if (parseFloat(mnode.PreviousFields.LowLimit.value) > 0 && parseFloat(mnode.FinalFields.LowLimit.value) === 0) {\n\n                        var currency = mnode.FinalFields.HighLimit.currency,\n                            trusting_party = mnode.FinalFields.LowLimit.issuer,\n                            trusted_party = mnode.FinalFields.HighLimit.issuer;\n\n                        emit([trusted_party, currency].concat(timestamp), {incoming: -1});\n                        emit([trusting_party, currency].concat(timestamp), {outgoing: -1});\n                    }\n\n                }\n\n                // balance changed\n                if (mnode.PreviousFields.hasOwnProperty(\"Balance\")) {\n\n                    var currency = mnode.FinalFields.Balance.currency,\n                        low_party = mnode.FinalFields.LowLimit.issuer,\n                        high_party = mnode.FinalFields.HighLimit.issuer;\n\n                    emit([low_party, currency].concat(timestamp), {balance_change: (mnode.FinalFields.Balance.value - mnode.PreviousFields.Balance.value)});\n                    emit([high_party, currency].concat(timestamp), {balance_change: (0 - (mnode.FinalFields.Balance.value - mnode.PreviousFields.Balance.value))});\n\n                }\n            }\n        }\n    }\n}",
          "reduce": "function(keys, values) {\n\n    var results = {\n        \"incoming\": 0,\n        \"outgoing\": 0,\n        \"balance_change\": 0\n    };\n\n    values.forEach(function(val){\n        if (typeof val.incoming === \"number\")\n            results.incoming += val.incoming;\n        if (typeof val.outgoing === \"number\")\n            results.outgoing += val.outgoing;\n        if (typeof val.balance_change === \"number\")\n            results.balance_change += val.balance_change;\n    });\n\n    return results;\n}"
        },
        "trustlineStatsByCurrency": {
          "map": "function(doc) {\n    var time = new Date(doc.close_time_timestamp),\n        timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                     time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n    for (var t = 0, txs = doc.transactions.length; t < txs; t++) {\n        var tx = doc.transactions[t];\n        \n        if (tx.metaData.TransactionResult !== \"tesSUCCESS\") \n            continue;\n        \n        for (var n = 0, nodes = tx.metaData.AffectedNodes.length; n < nodes; n++) {\n\n            if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"CreatedNode\") && tx.metaData.AffectedNodes[n].CreatedNode.LedgerEntryType === \"RippleState\") {\n                var cnode = tx.metaData.AffectedNodes[n].CreatedNode;\n\n                var currency = cnode.NewFields.Balance.currency,\n                    high_party = cnode.NewFields.HighLimit.issuer,\n                    low_party = cnode.NewFields.LowLimit.issuer;\n\n                if (parseFloat(cnode.NewFields.LowLimit.value) > 0) {\n                    emit([currency, high_party].concat(timestamp), {\"incoming\": 1});\n                    emit([currency, low_party].concat(timestamp), {\"outgoing\": 1});\n                }\n\n                if (parseFloat(cnode.NewFields.HighLimit.value) > 0) {\n                    emit([currency, low_party].concat(timestamp), {\"incoming\": 1});\n                    emit([currency, high_party].concat(timestamp), {\"outgoing\": 1});\n                }\n\n                if (parseFloat(cnode.NewFields.Balance.value) !== 0) {\n                    emit([currency, high_party].concat(timestamp), {\"balance_change\": 0 - parseFloat(cnode.NewFields.Balance.value)});\n                    emit([currency, low_party].concat(timestamp), {\"balance_change\": parseFloat(cnode.NewFields.Balance.value)});\n                }\n\n            } else if (tx.metaData.AffectedNodes[n].hasOwnProperty(\"ModifiedNode\") && tx.metaData.AffectedNodes[n].ModifiedNode.LedgerEntryType === \"RippleState\") {\n                var mnode = tx.metaData.AffectedNodes[n].ModifiedNode;\n\n                // high limit changed\n                if (mnode.PreviousFields.hasOwnProperty(\"HighLimit\")) {\n\n                    // adding trust line\n                    if (parseFloat(mnode.PreviousFields.HighLimit.value) === 0 && parseFloat(mnode.FinalFields.HighLimit.value) > 0) {\n\n                        var currency = mnode.FinalFields.LowLimit.currency,\n                            trusting_party = mnode.FinalFields.HighLimit.issuer,\n                            trusted_party = mnode.FinalFields.LowLimit.issuer;\n\n                        emit([currency, trusted_party].concat(timestamp), {\"incoming\": 1});\n                        emit([currency, trusting_party].concat(timestamp), {\"outgoing\": 1});\n                    }\n\n                    // removing trust line\n                    if (parseFloat(mnode.PreviousFields.HighLimit.value) > 0 && parseFloat(mnode.FinalFields.HighLimit.value) === 0) {\n\n                        var currency = mnode.FinalFields.LowLimit.currency,\n                            trusting_party = mnode.FinalFields.HighLimit.issuer,\n                            trusted_party = mnode.FinalFields.LowLimit.issuer;\n\n                        emit([currency, trusted_party].concat(timestamp), {\"incoming\": -1});\n                        emit([currency, trusting_party].concat(timestamp), {\"outgoing\": -1});\n                    }\n\n                }\n\n\n                // low limit changed\n                if (mnode.PreviousFields.hasOwnProperty(\"LowLimit\")) {\n\n                    // adding trust line\n                    if (parseFloat(mnode.PreviousFields.LowLimit.value) === 0 && parseFloat(mnode.FinalFields.LowLimit.value) > 0) {\n\n                        var currency = mnode.FinalFields.HighLimit.currency,\n                            trusting_party = mnode.FinalFields.LowLimit.issuer,\n                            trusted_party = mnode.FinalFields.HighLimit.issuer;\n\n                        emit([currency, trusted_party].concat(timestamp), {\"incoming\": 1});\n                        emit([currency, trusting_party].concat(timestamp), {\"outgoing\": 1});\n                    }\n\n                    // removing trust line\n                    if (parseFloat(mnode.PreviousFields.LowLimit.value) > 0 && parseFloat(mnode.FinalFields.LowLimit.value) === 0) {\n\n                        var currency = mnode.FinalFields.HighLimit.currency,\n                            trusting_party = mnode.FinalFields.LowLimit.issuer,\n                            trusted_party = mnode.FinalFields.HighLimit.issuer;\n\n                        emit([currency, trusted_party].concat(timestamp), {\"incoming\": -1});\n                        emit([currency, trusting_party].concat(timestamp), {\"outgoing\": -1});\n                    }\n\n                }\n\n                // balance changed\n                if (mnode.PreviousFields.hasOwnProperty(\"Balance\")) {\n\n                    var currency = mnode.FinalFields.Balance.currency,\n                        low_party = mnode.FinalFields.LowLimit.issuer,\n                        high_party = mnode.FinalFields.HighLimit.issuer;\n\n                    emit([currency, low_party].concat(timestamp), {\"balance_change\": (mnode.FinalFields.Balance.value - mnode.PreviousFields.Balance.value)});\n                    emit([currency, high_party].concat(timestamp), {\"balance_change\": (0 - (mnode.FinalFields.Balance.value - mnode.PreviousFields.Balance.value))});\n\n                }\n            }\n        }\n    }\n}",
          "reduce": "function (keys, values) {\n    var results = {\"incoming\": 0, \"outgoing\": 0, \"balance_change\": 0};\n\n    for (var v = 0, vlen = values.length; v < vlen; v++) {\n        if (typeof values[v].incoming === \"number\")\n            results.incoming += values[v].incoming;\n        if (typeof values[v].outgoing === \"number\")\n            results.outgoing += values[v].outgoing;\n        if (typeof values[v].balance_change === \"number\")\n            results.balance_change += values[v].balance_change;\n    }\n\n    return results;\n}"
        },
        "xrp_totals": {
          "map": "function(doc) {\n  var transactions = doc.transactions;\n\n  var time = new Date(doc.close_time_timestamp),\n      timestamp = [time.getUTCFullYear(), time.getUTCMonth(), time.getUTCDate(), \n                   time.getUTCHours(), time.getUTCMinutes(), time.getUTCSeconds()];\n\n  var ledger_index = doc.ledger_index;\n      \n  for (var i = 0, n = transactions && transactions.length; i < n; ++i) {\n    var t = transactions[i],\n        meta = t.metaData,\n        affected = meta.AffectedNodes;\n    if (meta.TransactionResult !== \"tesSUCCESS\") continue;\n    for (var j = 0; j < affected.length; ++j) {\n      var a = affected[j],\n          node = a.ModifiedNode || a.CreatedNode || a.DeletedNode,\n          fields;\n      if (!node || node.LedgerEntryType !== \"AccountRoot\") continue;\n      if (a.DeletedNode) log(\"deleted account!\");\n      if (fields = node.FinalFields || node.NewFields) {\n        emit([fields.Account].concat(timestamp), parseInt(fields.Balance, 10));\n      }\n    }\n  }\n}",
          "reduce": "function(keys, values, rereduce) {\n    if (!rereduce) {\n\n        // key [account, year, month, day, hour, minute, second]\n        // value balance\n\n        var most_recent = keys[a][0].slice(1),\n            acct_balance = values[0];\n\n        for (var a = 0, num_keys = keys.length; a < num_keys; a++) {\n            var timestamp = keys[a][0].slice(1);\n\n            if (lessThan(most_recent, timestamp)) {\n                most_recent = timestamp;\n                acct_balance = values[a];\n            }\n        }\n\n        return [acct_balance].concat(most_recent);\n\n    } else {\n\n        var most_recent = values[0][0].slice(1),\n            acct_balance = values[0][0];\n\n        for (var a = 0, num_vals = values.length; a < num_vals; a++) {\n            var timestamp = values[a][0].slice(1);\n\n            if (lessThan(most_recent, timestamp)) {\n                most_recent = timestamp;\n                acct_balance = values[a][0];\n            }\n        }\n\n        return [acct_balance].concat(most_recent);\n\n    }\n\n    function lessThan(arr1, arr2) {\n        if (arr1.length !== arr2.length)\n            return false;\n\n        for (var i = 0; i < arr1.length; i++) {\n            if (arr1[i] < arr2[i]) {\n                return true;\n            } else if (arr1[i] > arr2[i]) {\n                return false;\n            } else {\n                continue;\n            }\n        }\n\n        return false;\n    }\n}"
        }
      }
    }
  ]
}